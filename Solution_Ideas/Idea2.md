Option 2 – Modular Worker-based Architecture
Architecture:
MCP server acts as orchestrator.
File docs are generated by worker modules, one per language (Python worker, JS worker, Go worker, etc.).
Workers run in parallel and push structured output to a central store (JSON, database, or vector DB).
A doc aggregator service compiles bottom-up documentation across modules → packages → repo.
Tech Stack:
MCP server as orchestrator (handles repo traversal + worker coordination).
Workers can be Dockerized microservices.
Message queue (e.g., Redis, RabbitMQ, Kafka) for scaling.
Persistent storage (Postgres, SQLite, or vector DB like Weaviate).

Pros:
Scales better with large/multi-language repos.
Easy to add support for new languages (just add a worker).
Fault isolation — one worker failing doesn’t block others.

Cons:
More complex setup and ops.
Higher infra overhead (queues, containers, storage).